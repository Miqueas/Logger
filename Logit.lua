--[[
  Author: Miqueas Martinez (https://github.com/Miqueas)
  Co-Author: Nelson "darltrash" LÃ³pez (https://github.com/darltrash)
  Date: 2020/09/12
  License: MIT (see it in the repository)
  Git Repository: https://github.com/Miqueas/Logit
]]

local Logit = {}
local unp = table.unpack or unpack
local esc = string.char(27) -- 0x1b: see the Wikipedia link below

-- Helper function to create color escape-codes. Read this for more info:
-- https://en.wikipedia.org/wiki/ANSI_escape_code
-- One or more numbers expected
local function e(...)
  return esc.."["..table.concat({...}, ";").."m"
end

-- String templates
local Fmt = {
  Out = {
    Console  = e(2).."%s ["..e(0,1).."%s %s%s"..e(0,2).."] %s@%s:"..e(0).." %s",
    LogFile  = "%s [%s %s] %s@%s: %s"
  },
  FName = "%s_%s.log",
  Time = "%H:%M:%S"
}

-- Return true if 'path' exists or false if not
local function DirExists(path)
  local f = io.open(path)
  return (f and f:close()) and true or false
end

-- Appends a / or a \ (depending on the OS's directory system) at the end of a path string
local function DirNormalize(str)
  local str = tostring(str or "")
  local posix = (jit) and not (jit.os == "Windows") or os.getenv("HOME")

  if posix then
    -- POSIX
    str = (not str:find("%/+", -1)) and str.."/" or str
  else
    -- Windows
    str = (not str:find("%\\+", -1))
      and str:gsub("/", "\\") .. "\\"
       or str:gsub("/", "\\")
  end

  return str
end

-- The default log level
local LogLvl = 2
-- Header template
local LogHeader = "\n"..e(2).."%s ["..e(0,1).."%s"..e(0,2).."]"..e(0).."\n"

local LogType = {
  [0] = { Name = "OTHER", Color = "30" },
  [1] = { Name = "TRACE", Color = "32" },
  [2] = { Name = "DEBUG", Color = "36" },
  [3] = { Name = "INFO.", Color = "34" },
  [4] = { Name = "WARN.", Color = "33" },
  [5] = { Name = "ERROR", Color = "31" },
  [6] = { Name = "FATAL", Color = "35" }
}

-- Path where log files are saved
Logit.Path       = "./"
Logit.Namespace  = "Logit"
-- By default, Logit don't write logs to the terminal
Logit.Console    = false
Logit.FileSuffix = "%Y-%m-%d"

local function IsLogLevel(str)
  if type(str) == "string" then
    for i = 0, #LogType do
      if str:upper() == LogType[i].Name:gsub("%.", "") then
        return i
      end
    end
    return false
  else return false end
end

function Logit:new(name, dir, console, suffix, header, ...)
  local err = "Bad argument #%s to 'new()', '%s' expected, got %s"

  -- Arguments type check
  assert(
    type(name) == "string" or type(name) == "nil",
    err:format(1, "string", type(name))
  )

  assert(
    type(dir) == "string" or type(dir) == "nil",
    err:format(2, "string",  type(dir))
  )

  assert(
    type(console) == "boolean" or type(console) == "nil",
    err:format(3, "boolean", type(console))
  )

  assert(
    type(suffix) == "string" or type(suffix) == "nil",
    err:format(4, "string",  type(suffix))
  )

  assert(
    type(header) == "string" or type(header) == "nil",
    err:format(5, "string",  type(header))
  )
  -- End Arguments type check

  local o = setmetatable({}, { __call = self.log, __index = self })
  o.Namespace  = name or self.Namespace
  o.Console    = console or self.Console
  o.FileSuffix = suffix or self.FileSuffix

  -- If 'dir' is nil or an empty string, then uses the current
  -- path for the logs files
  if not dir or  #dir == 0 then
    o.Path = self.Path

  -- Or converts 'dir' to a valid path (if exists)
  elseif dir and DirExists(dir) then
    o.Path = DirNormalize(dir)

  -- Or stops if the path doesn't exists
  elseif dir and not DirExists(dir) then
    error("Path '"..dir.."' doesn't exists or you don't have permissions to use it.")

  -- Or... Idk... Unexpected errors can happen!
  else
    error("Unknown error while checking (and/or loading) '"..dir.."'... (argument #2 in 'new()')")
  end

  -- Writes a header at begin of the log
  local header = header and header:format(...) or "AUTOGENERATED BY LOGGER"
  local time = os.date(Fmt.Time)
  local file = io.open(
    o.Path..Fmt.FName:format(
      o.Namespace,
      os.date(o.FileSuffix)
    ),
    "a+"
  )

  -- The gsub at the end removes color escape-codes
  local fout = LogHeader:format(time, header):gsub(esc.."%[(.-)m", "")
  file:write(fout)
  file:close()

  -- Header is written, so... Returns the new Logit instance!
  return o
end

function Logit:log(msg, lvl, ...)
  -- 'lvl' is optional and if isn't a log level ("error", "warn", etc...),
  -- assumes that is part of '...'
  local lvl = IsLogLevel(lvl) or LogLvl
  local va  = IsLogLevel(lvl) and {...} or { lvl, ... }
  -- 'log()' assumes that 'msg' is an string
  local msg = tostring(msg)

  -- This prevents that 'Logit.lua' appears in the log message when 'expect()' is called.
  -- Basically it's like the ternary operator in C:
  --    (exp) ? TRUE : FALSE
  local info = (debug.getinfo(2, "Sl").short_src:find("(Logit.lua)"))
    and debug.getinfo(3, "Sl")
     or debug.getinfo(2, "Sl")

  -- The log file
  local file = io.open(
    self.Path .. Fmt.FName:format(
      self.Namespace,
      os.date(self.FileSuffix)
    ),
    "a+"
  )

  -- Prevents put different times in the file and the standard output
  local time = os.date(Fmt.Time)
  local fout = Fmt.Out.LogFile:format(
    time,
    self.Namespace,
    -- Name of the type of log
    LogType[lvl].Name,
    -- Source file from 'log()' is called
    info.short_src, -- Line where is called
    info.currentline,
    msg:format(unp(va))
      -- Removes ANSI SGR codes
      :gsub("("..esc.."%[(.-)m)", "")
  )

  -- The '\n' makes logs divide by lines instead of accumulating
  file:write(fout.."\n")
  file:close()

  if self.Console then
    local cout = Fmt.Out.Console:format(
      time,
      self.Namespace,
      -- Uses the correct color for differents logs
      e(LogType[lvl].Color),
      LogType[lvl].Name,
      info.short_src,
      info.currentline,
      -- Here we don't remove ANSI codes because we want a colored output
      msg:format(unp(va))
    )
    print(cout)
  end

  if lvl > 4 then
    -- A log level major to 4 causes the program to stop
    self:header(e(31).."SOMETHING WENT WRONG!")

    -- For Love2D compatibility
    if love then love.event.quit() end
    os.exit(1)
  end
end

function Logit:expect(exp, msg, lvl, ...)
  -- 'expect()' is mainly for errors
  if not exp then self:log(msg, IsLogLevel(lvl) or "error", ...)
  else return exp end
end

-- Write a log "header". May util if you want to separate some logs or create "breakpoints", etc...
function Logit:header(msg, ...)
  if type(msg) == "string" and #msg > 0 then
    local msg = msg:format(...)
    local time = os.date(Fmt.Time)
    local file = io.open(
      self.Path..Fmt.FName:format(
        self.Namespace,
        os.date(self.FileSuffix)
      ),
      "a+"
    )

    -- The gsub at the end removes color escape-codes
    local fout = LogHeader:format(time, msg):gsub(esc.."%[(.-)m", "")
    file:write(fout)
    file:close()

    if self.Console then
      print(LogHeader:format(time, msg))
    end
  end
end

function Logit:setLogLvl(lvl)
  -- Now, Logit only take strings for log levels
  local lvl = (type(lvl) == "string") and lvl
  LogLvl    = IsLogLevel(lvl) or 2
end

function Logit:setFileSuffix(str)
  local str = (type(str) == "string" and #str > 0)
    and str
     or "%Y-%m-%d"

  self.FileSuffix = str
end

return setmetatable(Logit, { __call = Logit.new, __index = Logit })
